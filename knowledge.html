<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Knowledge Base</title>
    <!-- 구글폰트 - Montserrat -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
  
    <!-- Pretendard 폰트 -->
    <link rel="stylesheet" as="style" crossorigin href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css" />
    <!--<link rel="stylesheet" href="C:\Users\82104\Desktop\유레카\style_bio.css">-->

    <style> 
        body {
            margin: 0px;
            padding: 0px;
            background-color:aliceblue
        }    

        html, body {
            font-family: 'Montserrat', Pretendard, -apple-system, BlinkMacSystemFont, system-ui, Roboto, 'Helvetica Neue', 'Segoe UI', 'Apple SD Gothic Neo', 'Noto Sans KR', 'Malgun Gothic', 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', sans-serif;
        }

        .logo {
            color: #ed5c28;
            text-transform: uppercase;
            font-weight: bold;
            font-size: 28px;
            text-align: center;
        }

        .logo strong {
            color: #ed5c28;
        }

        #logo {
            text-decoration: none;
        }

        #menu ul {
            list-style: none;
            padding: 0;
            margin: 0;
            text-align: center;
        }

        #menu li {
            display: inline-block;
        }

        #menu a {
            text-decoration: none;
            display: block;
            padding: 25px;
            font-weight: bold;
            color: #6072e8;
        }
        
        footer {
            text-align: center;
            padding-bottom: 3em;
        }

        table {
            text-align: center;
        }



        /**.container {
            width: 1200px;
            margin: 0 auto;
        } 가운데 정렬 **/

        #header-wrapper {
            background-size: 100%;
            padding: 1em 0em 1em 0em; /**이거하니까 로고 부분 크기 늘어남. 크기 조절 패딩으로?**/
        }

        #menu-wrapper {
            border-top: 0.5px solid black;
            border-bottom: 0.5px solid black;

        }


        .stat, .java{
            padding-left: 7em;
            padding-right: 7em;
        }

        h2 {
            padding-left: 4.5em;
        }

        
    
    </style>
</head>
<body>
    <div id="wrapper"> 

        <div id="header-wrapper"> <!--맨위로고-->
            <div id="header" class="container">
                <div>
                    <h1 class="logo"><a id="logo" href="index.html">Nbeen<strong>Story</strong></a></h1>
                </div>
            </div>
        </div>

        <div id="menu-wrapper"> <!--네비게이션-->
            <div id="menu" class="container">
                <ul>
                    <li><a href="index.html">Home</a></li>
                    <li><a href="bio.html">Bio</a></li>
                    <li><a href="book.html">Book</a></li>
                    <li><a href="favorite.html">Favorite</a></li>
                    <li><a href="knowledge.html">Knowledge Base</a></li>
                </ul>
            </div>
        </div>
        
    </div>

    <div class="study">
        <h2>경영통계</h2>
        <div class="stat">
            <p><strong>귀무가설</strong> : 연구에서 검증해야하는 가설 (H0, 영가설, null hypothesis). 기본적으로는 참으로 추정하며 이를 거부하기 위해서는 증거가 필요함. 모집단의 특성에 대하여 옳다고 제안하는 주장임.
            * 차이가 없다 / 효과가 없다 / 같다 / 영향을 주지 않는다. 등으로 주로 서술</p>
            
            <p><strong>대립가설</strong> : 귀무가설과 반대되는 가설로 연구자가 입증되기를 기대하는, 예상하는 가설 (대안가설, H1, Ha, alternative hypothesis)
            * 차이가 있다 / 효과가 있다 / 다르다 / 영향을 준다. 등으로 주로 서술</p>
            
            <p><strong>귀무가설의 유의성 검정 (Null Hypothesis  Significance Test, NHST)</strong><br>
            귀무가설은 대립가설을 위한 것으로 "귀무가설이 거짓이니까 대안으로 참이 되는 가설, 대립가설을 채택한다."를 이끌어내고자 함. 귀무가설을 검증하는 것을 실패하며 이를 통해 간접적으로 새로운 대립가설을 확인하는 것이 주요 목적임. 이는 귀류법과 같음. ( * 귀류법 : 어떤 명제A를 증명하기위해 "명제A가 거짓이다."를 가정하고 증명하다가 모순을 발견하여 이를 통해 간접적으로 명제A가 참임을 증명하는 방법.)
            그렇다면 귀무가설에 대하 우선 참, 거짓 여부를 알아야함!즉 표본 데이터로 부터 귀무가설이 참이면 채택(Accept), 거짓이면 기각(Reject)으로 판단을 해야함.<br><br>
            (1) 귀무가설을 만들고, 대립가설을 만든다.<br>
            (2) 실험을 수행한다.<br>
            (3) 귀무가설이 거짓인 경우 - 귀무가설을 기각하고 그 대안인 대립가설을 채택한다.<br>
                귀무가설이 참인 경우 - 귀무가설을 채택한다.</p>
            
            
            <p><strong>머신러닝에서 회귀분석의 의미</strong><br>
            
            회귀분석은 종속 변수(목표)와 하나 이상의 독립 변수(예측 변수라고도 함) 간의 미래 사건을 예측하는 방법이다. 예를 들면, 난폭운전과 운전자에 의한 교통사고 총 건수 사이의 상관관계를 예측하거나 비즈니스 상황에서는 특정 금액을 광고에 사용했을 때와 그것이 판매에 미치는 영향 사이의 관계를 예측하는 데 사용할 수 있다.
            
            회귀분석은 머신러닝의 일반적인 모델 중 하나이다. 회귀분석 모델은 수치적 가치를 추정한다는 측면에서 관측치가 어느 범주에 속하는지를 식별하는 분류 모델과 다르다.
            
            회귀분석은 예측, 시계열 모델링 및 변수 간 인과관계 발견 등에 주로 사용된다.</p>
        
            
            
            <strong>1. 선형 회귀(Linear regression)</strong><br>
            머신러닝에서 가장 일반적인 회귀분석 유형이라고 할 수 있는 선형 회귀는 예측 변수와 종속 변수로 구성되며, 이 둘은 선형 방식으로 서로 연관지어져 있다. 선형 회귀는 위에서 설명한 대로 가장 적합한 선, 즉 최적적합선을 사용한다.
            변수들이 서로 선형적으로 연결되어 있는 경우 선형 회귀를 사용한다. 광고 지출 증가가 판매에 미치는 영향을 예측할 때 등이 예가 될 수 있다. 그러나 선형 회귀분석은 특이치에 영향을 받기 쉬우므로 빅데이터 집합을 분석하는 데 사용해서는 안 된다.
            <br>
            <br>

            <strong>2. 로지스틱 회귀(Logistic regression)</strong><br>
            종속 변수에 이산 값이 있는 경우, 다시 말해 0 또는 1, 참 또는 거짓, 흑 또는 백, 스팸 또는 스팸 아닌 것 등의 두 가지 값 중 하나만 취할 수 있는 경우 로지스틱 회귀를 사용하여 데이터를 분석할 수 있다.
            로지스틱 회귀는 S자형 곡선을 사용하여 대상 변수와 독립 변수 사이의 관계를 표시한다. 그러나 로지스틱 회귀 분석 방식은 대상 변수에서 거의 동일한 값이 발생하는 대규모 데이터 세트에서 가장 효과가 있다는 사실에 유의해야 한다. 이 경우, 변수들의 순위를 지정할 때 문제를 일으킬 수 있기 때문에 서로 상관성이 높은 독립 변수들이 데이터 집합에 포함되어서는 안 된다. (이것은 multicollinearity, 즉 다중공선성이라고 알려진 현상으로, 회귀 분석에서 사용된 모델의 일부 예측 변수가 다른 예측 변수와 상관 정도가 높아, 데이터 분석 시 부정적인 영향을 미치는 현상을 의미한다.)
            <br>
            <br>

            <strong>3. 리지 회귀(Ridge regression)<br></strong>
            그러나, 불가피하게 독립 변수들 사이에 높은 상관 관계가 있는 경우라면 리지 회귀가 더 적합한 접근방식이다. 다중 회귀라고도 불리는 리지 회귀는 정규화 또는 규제화(regularization) 기법으로 알려져 있으며 모델의 복잡성을 줄이는 데 사용된다. 또한 ‘리지 회귀 페널티’로 알려진 약간의 편향, 즉 바이어스(bias)를 사용하여 모델이 과대적합(overfitting)에 덜 취약하게 만든다.
            <br>
            <br>

            <strong>4. 라쏘 회귀(Lasso regression)<br></strong>
            라쏘 회귀는 리지 회귀와 같이 모델의 복잡성을 줄여주는 또 다른 정규화 기법이다. 회귀 계수의 절대 사이즈를 금지함으로써 복잡성을 줄인다. 리지 회귀와는 다르게 아예 계수 값을 0에 가깝게 만든다.
            그 장점은 기능 선택을 사용할 수 있다는 것이다. 데이터 집합에서 기능 세트를 선택하여 모델을 구축할 수 있다. 라쏘 회귀는 필요한 요소들만 사용하고 나머지를 0으로 설정함으로써 과대적합을 방지할 수 있다.
            <br>
            <br>

            <strong>5. 다항 회귀(Polynomial regression)<br></strong>
            다항 회귀는 선형 모델을 사용하여 비선형 데이터 집합을 모델링한다. 이것은 동그란 모양의 구멍에 네모난 모양의 못 또는 말뚝을 끼워 넣는 것과 같다. 다항 회귀는 독립 변수가 여러 개인 선형 회귀를 뜻하는 다중 선형 회귀와 비슷한 방식으로 작동하지만, 비선형 곡선을 사용한다. 즉, 데이터 포인트가 비선형 방식으로 존재할 때 사용한다.
            모델은 이 데이터 포인트들을 지정된 수준의 다항식 특성으로 변환하고 선형 모델을 사용하여 모델화한다. 선형 회귀에서 볼 수 있는 직선이 아닌 곡선의 다항식 선을 사용하여 최적적합을 수행한다. 그러나 이 모델은 과대적합으로 나타나기 쉬우므로 이상한 결과치를 피하기 위해서는 끝 부분의 곡선을 분석하는 것이 좋다.
            회귀 분석에는 위에서 소개한 것들보다 더 많은 종류가 있지만, 이 다섯 가지가 가장 일반적으로 사용되는 것들이다. 가장 적합한 모델을 선택하면 데이터가 가진 잠재력을 최대한 활용하여 더 큰 인사이트를 얻을 수 있다.</p>
            <br>
            <br>
        </div>
        <hr>

        <h2>자바</h2>
        <div class="java">
            <strong>객체지향프로그래밍(Object Oriented Programming)</strong><br>
            OOP(객체 지향 프로그래밍)이란 문제를 여러 개의 객체 단위로 나눠 작업하는 방식으로, 객체들이 서로 유기적으로 상호작용하는 프로그래밍 이론이다.
            대표적으로 Java와 C#이 객체 지향 프로그래밍 언어이다.<br><br>

            객체 : 세상에 존재하는 모든것, 프로그래밍에서의 객체는 데이터의 분산을 막기 위해 데이터와 기능을 하나로 묶은 그룹<br>
            [EX] 컴퓨터(객체) = 데이터(본체, 모니터, 키보드) + 기능(화면, 소리, 입력, 출력)<br><br>

            OOP는 코드 재사용성과 생산성의 향상 효과를 볼 수 있고, 유지보수의 편의성 덕택에 협업이 중요하고 규모가 큰 대형 프로젝트에 사용되는 프로그래밍 이론이다.<br><br><br>


            <strong>OOP의 장점</strong><br>
            -코드 재사용성 증가<br>
            -상속을 통해 프로그래밍시 코드의 재사용을 높일 수 있다.<br>
            -생산성 향상<br>
            -잘 설계된 클래스를 만들어서 독립적인 객체를 사용함으로써 개발의 생산성을 향상시킬 수 있다.<br>
            -자연적인 모델링<br>
            -우리 일상생활의 모습의 구조가 객체에 자연스럽게 녹아들어 있기 때문에 생각하고 있는 것을 그대로 자연스럽게 구현할 수 있다.<br>
            -유지보수의 우수성<br>
            -프로그램 수정시 추가, 수정을 하더라도 캡슐화를 통해 주변 영향이 적기때문에 유지보수가 쉬워서 매우 경제적이라할 수 있다.<br><br>
  
            <strong>OOP의 단점<br></strong>
            -개발속도가 느린점<br>
            -객체가 처리하려는 것에 대한 정확한 이해가 필요하기에 설계단계부터 많은 시간이 소모된다.<br>
            -실행속도가 느린점<br>
            -객체지향언어는 대체적으로 실행속도가 느리다.<br>
            -코딩 난이도 상승<br>
            -다중 상속이 지원되는 C++ 같은 경우에 너무 복잡해져 코딩의 난이도가 상승할 수 있다.<br><br>

            <strong>OOP 특징<br></strong>
            객체 지향 프로그래밍의 가장 큰 특징은 클래스를 이용해 연관 있는 처리 부분(함수)과 데이터 부분(변수)을 하나의 객체(인스턴스)로 묶어 생성해 사용한다는 점이다.<br>
            객체 지향 프로그래밍은 캡슐화, 추상화, 상속성, 다형성 네 가지 특성을 지닌다.
        </div>
    </div>


    <br>
    <hr>
    <p>
    <footer>Copyright &copy; Eunbeen Lim, school of MIS 2022</footer>

</body> 
</html>
